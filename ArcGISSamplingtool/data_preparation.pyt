# -*- coding: utf-8 -*-import arcpy##### Custom packages ###import osimport numpy as npimport geopandas as gpdimport rasteriofrom rasterio.windows import Windowfrom shapely.geometry import box # to define polygon object to extractfrom rasterio import features # Functions for working with features in a raster datasetdef point2mask(raster, polygon, points, out_root, width=256, height=256):    """"    raster: the raster image to generate training samples    polygon: selected regular tesselations where samples are taken, could be fishnet    points: points indicating building centroids. They could be generated either by direct digitization    or from feature to point    out_root: directory to save image and mask chips. It automatically adds "images" and "labels" folders    """    root_image = '{}/images'.format(out_root)    root_mask = '{}/labels'.format(out_root)    if not os.path.exists(root_mask):        os.makedirs(root_mask, exist_ok=True)    if not os.path.exists(root_image):        os.makedirs(root_image, exist_ok=True)    polys = gpd.read_file(polygon)    pts = gpd.read_file(points)    assert polys.crs == pts.crs, 'Polygon and Point features do not have the same coordinate reference system {}, {}'.format(polys.crs, pts.crs)    ref = rasterio.open(raster)    for i, geom in enumerate(polys.geometry):        lon_min, lat_min, lon_max, lat_max = geom.bounds        row, col = rasterio.transform.rowcol(ref.profile['transform'], lon_min, lat_max)        win = Window(col_off=col, row_off=row, width=width, height=height)        transform = rasterio.windows.transform(win, ref.profile['transform'])        image = ref.read(window=win)  # [:3, :, :]        sel_pts = [pts.geometry[j] for j in range(len(pts.geometry)) if pts.geometry[j].within(geom)]        pxs = [cc.x for cc in sel_pts]        pys = [cc.y for cc in sel_pts]        # https://rasterio.readthedocs.io/en/stable/api/rasterio.transform.html        row_, col_ = rasterio.transform.rowcol(transform, pxs, pys)        mask = np.zeros((height, width), np.uint8)        mask[row_, col_] = 1        print('sum of points', np.sum(mask), mask.shape)        profile_array = ref.profile        profile_mask = ref.profile        profile_array.update(            transform=transform,            width=width,            height=height)        profile_mask.update(            transform=transform,            count=1,            width=width,            height=height,            dtype=np.uint8)        with rasterio.open('{}/image_{}.tif'.format(root_image, i), 'w', **profile_array) as dst:            dst.write(image)        with rasterio.open('{}/mask_{}.tif'.format(root_mask, i), 'w', **profile_mask) as dst_:            dst_.write(mask.astype(np.uint8), 1)    def polygon2mask(raster, boundary, samples, out_root, column=None, width=256, height=256):    """"    raster: the raster image to generate training samples    bounds: selected regular tesselations where samples are taken, could be fishnet    samples: polygons indicating building footprints. They could be generated either by direct digitization    or from existing database    out_root: directory to save image and mask chips. It automatically adds "images" and "labels" folders    column: The column that contains values to write into the new raster    """    root_image = '{}/images'.format(out_root)    root_mask = '{}/labels'.format(out_root)    if not os.path.exists(root_mask):        os.makedirs(root_mask, exist_ok=True)    if not os.path.exists(root_image):        os.makedirs(root_image, exist_ok=True)    bounds_ = gpd.read_file(boundary)    polys = gpd.read_file(samples)    assert bounds_.crs == polys.crs, 'Polygon and Point features do not have the same \    coordinate reference system {}, {}'.format(bounds_.crs, polys.crs)    ref = rasterio.open(raster)    for i, geom in enumerate(bounds_.geometry):        lon_min, lat_min, lon_max, lat_max = geom.bounds        row, col = rasterio.transform.rowcol(ref.profile['transform'], lon_min, lat_max)        win = Window(col_off=col, row_off=row, width=256, height=256)        transform = rasterio.windows.transform(win, ref.profile['transform'])        image = ref.read(window=win)  # [:3, :, :]        aoi = box(lon_min, lat_min, lon_max, lat_max)  # geometry to clip samples within fishnet boundary        sel_polys = gpd.clip(polys, aoi)        if column is None:            shapes = ((geom, value) for geom, value in zip(sel_polys.geometry, [1]*len(sel_polys)))            if i == 0:                print('Specfic column is not selected to burn. Value of 1 will be written to all valid polygon pixel locations')        else:            shapes = ((geom, value) for geom, value in zip(sel_polys.geometry, sel_polys[column]))            if i == 0:                print('Values from column {} will be written to raster'.format(column))        profile_array = ref.profile        profile_mask = ref.profile        profile_array.update(            transform=transform,            width=width,            height=height)        profile_mask.update(            transform=transform,            count=1,            width=width,            height=height,            dtype=np.uint8)        with rasterio.open('{}/image_{}.tif'.format(root_image, i), 'w', **profile_array) as dst:            dst.write(image)        with rasterio.open('{}/mask_{}.tif'.format(root_mask, i), 'w', **profile_mask) as dst_:            # print(dir(dst_))            out_array = np.zeros((height, width), np.uint8)  # dst_.read(1)            mask = features.rasterize(shapes=shapes, fill=0, out=out_array, transform=dst_.transform)            dst_.write_band(1, mask)class Toolbox(object):    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "Toolbox"        self.alias = "toolbox"        # List of tool classes associated with this toolbox        self.tools = [RasterTool, PointTool, PolygontTool]class PointTool(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Point2Chip"        self.description = "This tool converts points to raster mask within selected fishnet polygons"        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        in_point = arcpy.Parameter(displayName="Input multipoint features",                                     name="in_point",                                     datatype="GPFeatureLayer",                                     parameterType="Required",                                     direction="Input")        in_poly = arcpy.Parameter(displayName="Input polygon features",                                     name="in_poly",                                     datatype="GPFeatureLayer",                                     parameterType="Required",                                     direction="Input")        in_rst = arcpy.Parameter(displayName="Input raster",                                 name="in_rst",                                 datatype=["DERasterDataset", "DERasterCatalog"],                                 parameterType="Required",                                 direction="Input")        height = arcpy.Parameter(displayName="Output chip height",                                 name="height",                                 datatype="GPLong",                                 parameterType="Optional",                                 direction="Input")                width = arcpy.Parameter(displayName="Output chip width",                                 name="width",                                 datatype="GPLong",                                 parameterType="Optional",                                 direction="Input")                out_location = arcpy.Parameter(displayName="Output folder",                                       name="out_location",                                       datatype="DEFolder",                                       parameterType="Required",                                       direction="Input")                in_point.filter.list = ["Point","Multipoint"]        height.value = 256        width.value = 256                        parameters = [in_point, in_poly, in_rst, height, width, out_location]                return parameters    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        inPt = parameters[0].valueAsText        inPoly = parameters[1].valueAsText        inRst = parameters[2].valueAsText        hT = parameters[3].value        wD = parameters[4].value        out_dir = parameters[5].valueAsText        point2mask(raster=inRst, polygon=inPoly, points=inPt, out_root=out_dir, width=wD, height=hT)                return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        returnclass PolygontTool(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Polygon2Chip"        self.description = "This tool converts points to raster mask within selected fishnet polygons"        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        in_sample = arcpy.Parameter(displayName="Input multipolygon features",                                     name="in_sample",                                     datatype="GPFeatureLayer",                                     parameterType="Required",                                     direction="Input")        class_col = arcpy.Parameter(displayName="Value Column",                                       name="class_col",                                       datatype="GPString",                                       parameterType="Optional",                                       direction="Input")   # as it is going to be selected from input layer                in_poly = arcpy.Parameter(displayName="Input polygon features",                                     name="in_poly",                                     datatype="GPFeatureLayer",                                     parameterType="Required",                                     direction="Input")                in_rst = arcpy.Parameter(displayName="Input raster",                                 name="in_rst",                                 datatype=["DERasterDataset", "DERasterCatalog"],                                 parameterType="Required",                                 direction="Input")        height = arcpy.Parameter(displayName="Output chip height",                                 name="height",                                 datatype="GPLong",                                 parameterType="Optional",                                 direction="Input")                width = arcpy.Parameter(displayName="Output chip width",                                 name="width",                                 datatype="GPLong",                                 parameterType="Optional",                                 direction="Input")                out_location = arcpy.Parameter(displayName="Output folder",                                       name="out_location",                                       datatype="DEFolder",                                       parameterType="Required",                                       direction="Input")                #in_sample.filter.list = ["Polygon"]        #in_poly.filter.list = ["Polygon"]        height.value = 256        width.value = 256                        parameters = [in_sample, class_col, in_poly, in_rst, height, width, out_location]                return parameters    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        if parameters[0].value and parameters[0].altered:            filds = arcpy.ListFields(parameters[0].valueAsText)            fildList = [field.name for field in filds]            parameters[1].filter.list = fildList            parameters[1].enabled  = True        if not parameters[1].altered:            parameters[1].value = None        return    def execute(self, parameters, messages):        """The source code of the tool."""        inSpl = parameters[0].valueAsText        try:            cVal = parameters[1].valueAsText        except:            cVal = parameters[1].value                    inPoly = parameters[2].valueAsText        inRst = parameters[3].valueAsText        hT = parameters[4].value        wD = parameters[5].value        out_dir = parameters[6].valueAsText        polygon2mask(raster=inRst, boundary=inPoly, samples=inSpl, out_root=out_dir, column=cVal, width=wD, height=hT) # main function                return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        returnclass RasterTool(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "SquareFishnet"        self.description = "This tool generates regular tesselations based on outut ship size(number of columns and rows) and image pixel resolution"        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""                in_rst = arcpy.Parameter(displayName="Input raster",                                 name="in_rst",                                 datatype=["DERasterDataset", "DERasterCatalog"],                                 parameterType="Required",                                 direction="Input")        height = arcpy.Parameter(displayName="Output chip height",                                 name="height",                                 datatype="GPLong",                                 parameterType="Optional",                                 direction="Input")                width = arcpy.Parameter(displayName="Output chip width",                                 name="width",                                 datatype="GPLong",                                 parameterType="Optional",                                 direction="Input")                x_size =arcpy.Parameter(displayName="Input image pixel size X",                                 name="x_size",                                 datatype="GPDouble",                                 parameterType="Optional",                                 direction="Input")                y_size = arcpy.Parameter(displayName="Input image pixel size Y",                                 name="y_size",                                 datatype="GPDouble",                                 parameterType="Optional",                                 direction="Input")                out_feature = arcpy.Parameter(displayName="Output Fishnet",                                       name="out_feature",                                       datatype="GPFeatureLayer",                                       parameterType="Required",                                       direction="Output")                #out_feature.filter.list = ["Polygon","MultiPolygon"]        #in_rst.filter.list = ['tif', 'tiff', 'img']                height.value = 256        width.value = 256                        parameters = [in_rst, height, width, x_size, y_size, out_feature]                return parameters    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""                if parameters[0].value and parameters[0].altered:            desc = arcpy.sa.Raster(parameters[0].valueAsText)            parameters[3].enabled  = True            parameters[4].enabled  = True            parameters[3].value = desc.meanCellHeight            parameters[4].value = desc.meanCellWidth        else:            parameters[3].enabled  = False            parameters[4].enabled  = False                    return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""                return    def execute(self, parameters, messages):        """The source code of the tool."""        rst = parameters[0].valueAsText        wdt = parameters[1].value        hit = parameters[2].value        xsz = parameters[3].value        ysz = parameters[4].value        out = parameters[5].valueAsText                description = arcpy.sa.Raster(rst)        extent = description.extent        w = wdt*ysz        h = hit*xsz        u = extent.spatialReference.linearUnitName        area = "{size} Square{unit}s".format(size=w * h, unit=u)        spatial_ref = extent.spatialReference        messages.addMessage('The area of a unit square is {}'.format(area))        messages.addMessage(extent)                arcpy.management.GenerateTessellation(out, extent, "SQUARE", area, spatial_ref)                return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return